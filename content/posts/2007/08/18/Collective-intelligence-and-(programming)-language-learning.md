---
title: "Collective Intelligence and (Programming) Language Learning"
date: 2007-08-18
draft: false
---

So, the other night at [DorkbotPDX](https://web.archive.org/web/20090205154227/http://dorkbotpdx.org/), there was a discussion about techniques for making images searchable. The idea was to come up with something beyond what [Google Images](https://web.archive.org/web/20090205154227/http://images.google.com/) gives you and have something more in depth -- among other things, the idea of categorizing things like [Pandora](https://web.archive.org/web/20090205154227/http://pandora.com/) does, using collective organization based on a large body of contributors, was discussed. There were a lot of interesting ideas thrown around, but most of them seemed to rely on this approach of using large social structures to generate the relevant metadata.

In a bit of the sort of serendipity that the internet seems to bring with near frightening regularity, the next day I read [this post](https://web.archive.org/web/20090205154227/http://radar.oreilly.com/archives/2007/08/programming_col.html) on O'Reilly Radar about the new O'Reilly book [Programming Collective Intelligence](https://web.archive.org/web/20090205154227/http://www.oreilly.com/catalog/9780596529321/index.html). This book appears to discuss exactly the kind of development tasks that are necessary to make possible the systems we were discussing. 

Intrigued by this, I downloaded the sample chapter and started reading. It's a very engaging book and I'm looking forward to getting my own copy. However, the example code is all in Python. I'm not a Python programmer, though I do have a good bit of familiarity with the language and, in the past, have written a handful of utilities using it. But even still, I don't think this would be an issue: I'm well familiar and to a degree quite versed in a handful of languages that are very similar to Python. Which makes it easy enough to understand what the examples are trying to do. 

This brought up a stream of thoughts, though, that have been rattling around in my head for some time now. The fact is that when it comes to languages like Python, Ruby, Java, C, etc. there is enough similarity that I can make my way through a given example (for those with which I am less familiar) without any great difficulty. The problem is that outside of these common paradigms (for lack of better descriptors, imperative and object-oriented) of programming languages, I am not so comfortable. 

Unfortunately, there is a growing undercurrent of languages that work outside of that world. Haskell Erlang, OCaml, Scala, Prolog... the list goes on. All very interesting and worth understanding, but I feel largely out of my depth when looking at examples in these environments. It's just not right. 

For a long time it's been clear to me that in order to continue to push my abilities as a developer and technologist in general, I need to continue to expand the scope of my understanding and knowledge. Functional, logical and other language styles are clearly a necessary addition to my repertoire. 